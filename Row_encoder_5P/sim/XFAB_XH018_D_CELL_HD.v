// This is the verilog file for XFAB XH018 digital libraries.
// Generated by autoscript written by Shouyu Xie.
// Date: Wed Mar 19 14:51:24 GMT 2025 
primitive check   (z, a, b);
    output z;
    input a, b ;

// FUNCTION :  Comparison cell

    table
    //  a   b       :   z
        1   0       :   1 ;
        0   1       :   1 ;
        x   0       :   1 ;
        x   1       :   1 ;
        0   x       :   1 ;
        1   x       :   1 ;
        0   0       :   0 ;
        1   1       :   0 ;

    endtable
endprimitive
primitive check_buf   (z, a, b);
    output z;
    input a, b ;

// FUNCTION :  Comparison cell

    table
    //  a    b      :   z
        1    1      :   1 ;
        x    1      :   x ;
	    0    1      :   0 ;
        1    x      :   x ;
        x    x      :   x ;
	    0    x      :   x ;

    endtable
endprimitive
primitive check_gnd   (z, a);
    output z;
    input a;

// FUNCTION :  Comparison cell

    table
    // a      :   z
       0      :   1 ;

    endtable
endprimitive
primitive check_vdd   (z, a);
    output z;
    input a;

// FUNCTION :  Comparison cell

    table
    // a      :   z
       1      :   1 ;

    endtable
endprimitive
primitive checkjk   (z, a, b);
    output z;
    input a, b ;

// FUNCTION :  Comparison cell

    table
    //  a   b       :   z
        1   ?       :   1 ;
        x   1       :   1 ;
        x   0       :   0 ;
        0   ?       :   0 ;

    endtable
endprimitive
primitive checkrs   (z, a, b);
    output z;
    input a, b ;

// FUNCTION :  Comparison cell

    table
    //  a    b      :   z
        1    1      :   1 ;
        x    1      :   1 ;
        1    x      :   1 ;
        0    1      :   0 ;
        0    x      :   0 ;
        1    0      :   0 ;
        x    0      :   0 ;
        0    0      :   0 ;

    endtable
endprimitive
primitive diff_lshifter   (z, a, an);
    output z;
    input a, an;
    reg z;

// FUNCTION :  differrential level shifter

    table
    // a   an :  zt-1 :  z
       0    1 :   ?   :  0 ;
       1    0 :   ?   :  1 ;
       1    1 :   ?   :  1 ;
       0    0 :   0   :  0 ;
       0    0 :   1   :  1 ;

    endtable
endprimitive
primitive prejk   (z, a, b, c);
    output z;
    input a, b, c ;

// FUNCTION :  Pre Driver Of JK FF

    table
    //  a   b   c   :   z
        0   1   ?   :   0 ;
        1   0   ?   :   1 ;
        x   0   0   :   1 ;
        x   1   0   :   0 ;
        0   x   1   :   0 ;
        1   x   1   :   1 ;
        1   1   1   :   1 ;
        1   1   0   :   0 ;
        0   0   0   :   1 ;
        0   0   1   :   0 ;

    endtable
endprimitive


module resistor_ams ( A, B );
//  
  inout A;
  inout B;
parameter r = 1 ;
tran TRAN (B,A); 
endmodule


module resistorswitch_ams ( A, B, E,power_vdd,ground_gnd);

  input power_vdd,ground_gnd;
  inout A;
  input E;
  inout B;
parameter ron = 0.1 ;
parameter roff = 1e+12 ;

tranif1 TRAN(A,B,E);
endmodule
primitive u1_fd4  (Q, D, C, RN, SN, NOTIFY);

    output Q;
    input  D, C, RN, SN, NOTIFY;
    reg    Q;

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH 
//            ASYNCHRONOUS ACTIVE LOW SET AND CLEAR.

    table

//  D    C    RN    SN   NTFY : Qt  : Qt+1
// ---- ---- ----- ----- ---- : --- : ----
// data clk  rst_n set_n ntfy : Qi  : Q_out           
// ---- ---- ----- ----- ---- : --- : ----

    *	 b    1     1	  ?   :  ?  :  -  ; // data changes, clk stable
    ?  (?0)   1     1	  ?   :  ?  :  -  ; // clocks off


    1  (0x)   1     ?	  ?   :  1  :  1  ; // possible clk of D=1, but Q=1
    0  (0x)   ?     1	  ?   :  0  :  0  ; // possible clk of D=0, but Q=0

    ?	 ?    1     0	  ?   :  ?  :  1  ; // async set
    ?	 ?    0     1	  ?   :  ?  :  0  ; // async reset
//    ?	 ?    0     0	  ?   :  ?  :  0  ; // async reset and set - only by xlicdd models possible 

    0  (01)   ?     1	  ?   :  ?  :  0  ; // clocking D=0
    1  (01)   1     ?	  ?   :  ?  :  1  ; // clocking D=1

   					    // reduced pessimism: 
    ?    ?  (?1)    1     ?   :  ?  :  -  ; // ignore the edges on rst_n
    ?    ?    1   (?1)    ?   :  ?  :  -  ; // ignore the edges on set_n

    1  (x1)   1     ?     ?   :  1  :  1  ; // potential pos_edge clk, potential set_n, but D=1 && Qi=1
    0  (x1)   ?     1     ?   :  0  :  0  ; // potential pos_edge clk, potential rst_n, but D=0 && Qi=0

    1  (1x)   1     ?     ?   :  1  :  1  ; // to_x_edge clk, but D=1 && Qi=1
    0  (1x)   ?     1     ?   :  0  :  0  ; // to_x_edge clk, but D=0 && Qi=0
    ?    ?    ?     ?     *   :  ?  :  x  ; // timing violation

`ifdef    ATPG_RUN

    ?	 *    1     0	  ?   :  ?  :  1  ; // clk while async set	      // ATPG
    ?	 *    0     1	  ?   :  ?  :  0  ; // clk while async reset	      // ATPG
    ?	 ?    1     x	  ?   :  1  :  1  ; //   set=X, but Q=1		      // ATPG
    ?    ?    x     1	  ?   :  0  :  0  ; // reset=X, but Q=0		      // ATPG

`else
   					    // reduced pessimism: 
    1	 ?    1     x	  ?   :  1  :  1  ; //   set=X, but Q=1    	      // Vlg
    0	 b    1   (0x)	  ?   :  1  :  1  ; //   set=X, D=0, but Q=1   	      // Vlg
    0	 b    1   (1x)	  ?   :  1  :  1  ; //   set=X, D=0, but Q=1   	      // Vlg
   (??)	 b    1     ?	  ?   :  1  :  1  ; //   set=X, D=egdes, but Q=1      // Vlg
    ?  (?0)   1     x	  ?   :  1  :  1  ; //   set=X, neg_edge clk, but Q=1 // Vlg

    0    ?    x     1	  ?   :  0  :  0  ; // reset=X, but Q=0    	      // Vlg
    1    b  (0x)    1	  ?   :  0  :  0  ; // reset=X, D=1, but Q=0   	      // Vlg
    1    b  (1x)    1	  ?   :  0  :  0  ; // reset=X, D=1, but Q=0   	      // Vlg
   (??)  b    ?     1	  ?   :  0  :  0  ; // reset=X, D=egdes, but Q=0      // Vlg
    ?  (?0)   x     1	  ?   :  0  :  0  ; // reset=X, neg_edge clk, but Q=0 // Vlg

 
`endif // ATPG_RUN

    endtable

endprimitive
primitive u1_fd5  (Q, D, C, RN, SN, NOTIFY);

    output Q;
    input  D, C, RN, SN, NOTIFY;
    reg    Q;

// FUNCTION : POSITIVE EDGE TRIGGERED D FLIP-FLOP WITH 
//            ASYNCHRONOUS ACTIVE LOW SET AND CLEAR.
//            with the correct behavioral if set and reset Low
    table

//  D    C    RN    SN   NTFY : Qt  : Qt+1
// ---- ---- ----- ----- ---- : --- : ----
// data clk  rst_n set_n ntfy : Qi  : Q_out           
// ---- ---- ----- ----- ---- : --- : ----

    *	 ?    1     1	  ?   :  ?  :  -  ; // data changes, clk stable
    ?    n    1     1	  ?   :  ?  :  -  ; // clock falling edge


    1  (0x)   1     ?	  ?   :  1  :  1  ; // possible clk of D=1, but Q=1
    0  (0x)   ?     1	  ?   :  0  :  0  ; // possible clk of D=0, but Q=0

    ?	 ?    1     0	  ?   :  ?  :  1  ; // async set
    ?	 ?    0     ?	  ?   :  ?  :  0  ; // async reset, set 0,1,x

    0  (01)   ?     1	  ?   :  ?  :  0  ; // clocking D=0
    1  (01)   1     ?	  ?   :  ?  :  1  ; // clocking D=1

   					                        // reduced pessimism: 
    ?    ?  (?1)    1     ?   :  ?  :  -  ; // ignore the edges on rst_n
    ?    ?    1   (?1)    ?   :  ?  :  -  ; // ignore the edges on set_n

    1  (x1)   1     ?     ?   :  1  :  1  ; // potential pos_edge clk, potential set_n, but D=1 && Qi=1
    0  (x1)   ?     1     ?   :  0  :  0  ; // potential pos_edge clk, potential rst_n, but D=0 && Qi=0
    ?    ?    ?     ?     *   :  ?  :  x  ; // timing violation

//    1  (1x)   1     ?     ?   :  1  :  1  ; // to_x_edge clk, but D=1 && Qi=1
//    0  (1x)   ?     1     ?   :  0  :  0  ; // to_x_edge clk, but D=0 && Qi=0

`ifdef    ATPG_RUN

    ?	 *    1     0	  ?   :  ?  :  1  ; // clk while async set	      // ATPG
    ?	 *    0     1	  ?   :  ?  :  0  ; // clk while async reset	      // ATPG
    ?	 ?    1     x	  ?   :  1  :  1  ; //   set=X, but Q=1		      // ATPG
    ?    ?    x     1	  ?   :  0  :  0  ; // reset=X, but Q=0		      // ATPG

`else
   					    // reduced pessimism: 
    1	 ?    1     x	  ?   :  1  :  1  ; //   set=X, but Q=1    	      // Vlg
    0	 b    1   (0x)	  ?   :  1  :  1  ; //   set=X, D=0, but Q=1   	      // Vlg
    0	 b    1   (1x)	  ?   :  1  :  1  ; //   set=X, D=0, but Q=1   	      // Vlg
   (??)	 b    1     ?	  ?   :  1  :  1  ; //   set=X, D=egdes, but Q=1      // Vlg
    ?  (?0)   1     x	  ?   :  1  :  1  ; //   set=X, neg_edge clk, but Q=1 // Vlg

    0    ?    x     1	  ?   :  0  :  0  ; // reset=X, but Q=0    	      // Vlg
    1    b  (0x)    1	  ?   :  0  :  0  ; // reset=X, D=1, but Q=0   	      // Vlg
    1    b  (1x)    1	  ?   :  0  :  0  ; // reset=X, D=1, but Q=0   	      // Vlg
   (??)  b    ?     1	  ?   :  0  :  0  ; // reset=X, D=egdes, but Q=0      // Vlg
    ?  (?0)   x     1	  ?   :  0  :  0  ; // reset=X, neg_edge clk, but Q=0 // Vlg

 
`endif // ATPG_RUN

    endtable

endprimitive
primitive u_ld1 (Q, D, G, NOTI_REG);

    output Q;
    reg    Q;
    input  D,              // data
           G,              // clock
           NOTI_REG;

// FUNCTION : DLATCH, GATED  STANDARD DRIVE / ACTIVE HIGH ( Q OUTPUT UDP )
//


   table
     //  D       G    NOTI_REG        : Qtn :   Qtn+1

         *       0      ?             :  ?  :    -   ;

         ?      (?0)    ?             :  ?  :    -   ;
         0      (1x)    ?             :  0  :    -   ;
         1      (1x)    ?             :  1  :    -   ;

         0      (0x)    ?             :  0  :    0   ;
         1      (0x)    ?             :  1  :    1   ;
         0      (x1)    ?             :  ?  :    0   ;
         1      (x1)    ?             :  ?  :    1   ;

        (?0)     1      ?             :  ?  :    0   ;
        (?1)     1      ?             :  ?  :    1   ;
         0      (01)    ?             :  ?  :    0   ;
         1      (01)    ?             :  ?  :    1   ;

        (?1)     x      ?             :  1  :    1   ;    // Reducing pessimism.
        (?0)     x      ?             :  0  :    0   ;

         ?       ?      *             :  ?  :    x   ;
 
   endtable
endprimitive
primitive u_ld4 (Q,D,G,SN,RN,NOTI_REG);
	output Q;
	input D,G,SN,RN,NOTI_REG;
	reg Q;

// function: D latch active high with reset and set

table
//         D       G      SN    RN   NOTI_REG       : Qtn :   Qtn+1

         *       0      1     1     ?             :  ?  :    -   ;
         ?       ?      1     0     ?             :  ?  :    0   ; // asynchro clear
         ?       ?      0     1     ?             :  ?  :    1   ; // asynchro set

         ?      (?0)    1     1     ?             :  ?  :    -   ;
         0      (1x)    1     1     ?             :  0  :    -   ;
         1      (1x)    1     1     ?             :  1  :    -   ;

         0      (0x)    1     1     ?             :  0  :    0   ;
         1      (0x)    1     1     ?             :  1  :    1   ;
         0      (x1)    1     1     ?             :  ?  :    0   ;
         1      (x1)    1     1     ?             :  ?  :    1   ;

        (?0)     1      1     x     ?             :  ?  :    0   ;
        (?0)     1      1     1     ?             :  ?  :    0   ;
        (?1)     1      1     1     ?             :  ?  :    1   ;
         0      (01)    1     1     ?             :  ?  :    0   ;
         1      (01)    1     1     ?             :  ?  :    1   ;
         1      (01)    x     1     ?             :  ?  :    1   ;

         0      (01)    x     1     ?             :  ?  :    0   ;
         0       ?      x     1     ?             :  0  :    0   ;   // Reducing pessimism.
         1       ?      1     x     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       0     (?1)   1     ?             :  ?  :    -   ;   // ignore edge on clear
         0       1     (?1)   1     ?             :  ?  :    0   ;   // pessimism .
         1       1     (?1)   1     ?             :  ?  :    1   ;
         ?       0      1     (?1)  ?             :  ?  :    -   ;   // ignore edge on set
         0       1      1     (?1)  ?             :  ?  :    0   ;   // pessimism .
         1       1      1     (?1)  ?             :  ?  :    1   ;
 
        (?1)     x      1     1     ?             :  1  :    1   ;   // Reducing pessimism.
        (?0)     x      1     1     ?             :  0  :    0   ;   // Reducing pessimism.
 
         ?       0      1     x     ?             :  0  :    0   ;   // Reducing pessimism.
         ?       0      x     1     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       ?      ?     ?     *             :  ?  :    x   ;
           
endtable
endprimitive
primitive u_ld5 (Q,D,G,SN,RN,NOTI_REG);
	
    output Q;
	input D,G,SN,RN,NOTI_REG;
	reg Q;
	
//          function: D latch active high with reset and set
//          with the correct behavioral if set and reset Low

table
//         D       G      SN    RN   NOTI_REG       : Qtn :   Qtn+1

         *       0      1     1     ?             :  ?  :    -   ;
         ?       ?      1     0     ?             :  ?  :    0   ; // asynchro clear
         ?       ?      0     1     ?             :  ?  :    1   ; // asynchro set
         ?       ?      0     0     ?             :  ?  :    0   ; // set and clear

         ?      (?0)    1     1     ?             :  ?  :    -   ;
         0      (1x)    1     1     ?             :  0  :    -   ;
         1      (1x)    1     1     ?             :  1  :    -   ;

         0      (0x)    1     1     ?             :  0  :    0   ;
         1      (0x)    1     1     ?             :  1  :    1   ;
         0      (x1)    1     1     ?             :  ?  :    0   ;
         1      (x1)    1     1     ?             :  ?  :    1   ;

        (?0)     1      1     x     ?             :  ?  :    0   ;
        (?0)     1      1     1     ?             :  ?  :    0   ;
        (?1)     1      1     1     ?             :  ?  :    1   ;
         0      (01)    1     1     ?             :  ?  :    0   ;
         1      (01)    1     1     ?             :  ?  :    1   ;
         1      (01)    x     1     ?             :  ?  :    1   ;

         0      (01)    x     1     ?             :  ?  :    0   ;
         0       ?      x     1     ?             :  0  :    0   ;   // Reducing pessimism.
         1       ?      1     x     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       0     (?1)   1     ?             :  ?  :    -   ;   // ignore edge on clear
         0       1     (?1)   1     ?             :  ?  :    0   ;   // pessimism .
         1       1     (?1)   1     ?             :  ?  :    1   ;
         ?       0      1     (?1)  ?             :  ?  :    -   ;   // ignore edge on set
         0       1      1     (?1)  ?             :  ?  :    0   ;   // pessimism .
         1       1      1     (?1)  ?             :  ?  :    1   ;
 
        (?1)     x      1     1     ?             :  1  :    1   ;   // Reducing pessimism.
        (?0)     x      1     1     ?             :  0  :    0   ;   // Reducing pessimism.
 
         ?       0      1     x     ?             :  0  :    0   ;   // Reducing pessimism.
         ?       0      x     1     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       ?      ?     ?     *             :  ?  :    x   ;
           
endtable
endprimitive
primitive u_ld6 (Q,D,G,SN,RN,NOTI_REG);
	
    output Q;
	input D,G,SN,RN,NOTI_REG;
	reg Q;
	
//          function: D latch active high with reset and set
//          with the correct behavioral if set and reset Low

table
//         D       G      SN    RN   NOTI_REG       : Qtn :   Qtn+1

         *       0      1     1     ?             :  ?  :    -   ;
         ?       ?      1     0     ?             :  ?  :    0   ; // asynchro clear
         ?       ?      0     1     ?             :  ?  :    1   ; // asynchro set
         ?       ?      0     0     ?             :  ?  :    1   ; // set and clear

         ?      (?0)    1     1     ?             :  ?  :    -   ;
         0      (1x)    1     1     ?             :  0  :    -   ;
         1      (1x)    1     1     ?             :  1  :    -   ;

         0      (0x)    1     1     ?             :  0  :    0   ;
         1      (0x)    1     1     ?             :  1  :    1   ;
         0      (x1)    1     1     ?             :  ?  :    0   ;
         1      (x1)    1     1     ?             :  ?  :    1   ;

        (?0)     1      1     x     ?             :  ?  :    0   ;
        (?0)     1      1     1     ?             :  ?  :    0   ;
        (?1)     1      1     1     ?             :  ?  :    1   ;
         0      (01)    1     1     ?             :  ?  :    0   ;
         1      (01)    1     1     ?             :  ?  :    1   ;
         1      (01)    x     1     ?             :  ?  :    1   ;

         0      (01)    x     1     ?             :  ?  :    0   ;
         0       ?      x     1     ?             :  0  :    0   ;   // Reducing pessimism.
         1       ?      1     x     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       0     (?1)   1     ?             :  ?  :    -   ;   // ignore edge on clear
         0       1     (?1)   1     ?             :  ?  :    0   ;   // pessimism .
         1       1     (?1)   1     ?             :  ?  :    1   ;
         ?       0      1     (?1)  ?             :  ?  :    -   ;   // ignore edge on set
         0       1      1     (?1)  ?             :  ?  :    0   ;   // pessimism .
         1       1      1     (?1)  ?             :  ?  :    1   ;
 
        (?1)     x      1     1     ?             :  1  :    1   ;   // Reducing pessimism.
        (?0)     x      1     1     ?             :  0  :    0   ;   // Reducing pessimism.
 
         ?       0      1     x     ?             :  0  :    0   ;   // Reducing pessimism.
         ?       0      x     1     ?             :  1  :    1   ;   // Reducing pessimism.

         ?       ?      ?     ?     *             :  ?  :    x   ;
           
endtable
endprimitive
primitive u_mx2 (Y,D0,D1,S);
          output Y;
          input D0,D1,S;
 
table
     //  D0    D1   S   :  Y ;
          0     ?   0   :  0 ;
          1     ?   0   :  1 ;
          ?     0   1   :  0 ;
          ?     1   1   :  1 ;
          0     0   x   :  0 ;
          1     1   x   :  1 ;
endtable
endprimitive
`timescale 1ns/10ps

`celldefine

module AN211HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN211HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN211HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN211HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN211HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN211HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN211HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN211HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C+D)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN21HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN21HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN21HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN21HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN21HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN21HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN21HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN21HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B)+C)
	and	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN221HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN221HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN221HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN221HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN221HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN221HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN221HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN221HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN222HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN222HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN222HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN222HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN222HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN222HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN222HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN222HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	nor	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F -=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN22HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN22HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN22HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN22HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN311HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN311HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN311HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN311HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN311HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN311HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN311HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN311HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN31HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN31HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN31HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN31HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN31HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN31HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN31HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN31HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	nor	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN321HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN321HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN321HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN321HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN321HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN321HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN321HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN321HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = 
		(0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN32HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN32HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN32HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN32HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN32HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN32HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN32HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN32HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D -=> Q) = 
		(0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN33HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN33HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN33HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN33HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN33HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN33HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AN33HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AN33HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	nor	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A*B)
	and	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A*B*C)
	and	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND4HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND4HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND4HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND4HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A*B*C*D)
	and	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND5HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND5HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND5HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND5HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E)
	and	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND6HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND6HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND6HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND6HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND6HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND6HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AND6HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AND6HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A*B*C*D*E*F)
	and	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ANTENNACELLN2HD (A);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ANTENNACELLN2HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : protection cell against antenna effects (net charge) at manufacture, NIMP diode in 
//   substrate
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ANTENNACELLNP2HD (A);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ANTENNACELLNP2HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : protection cell against antenna effects (net charge) at manufacture, PIMP diode in 
//   NWELL, NIMP diode in substrate
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ANTENNACELLP2HD (A);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ANTENNACELLP2HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : protection cell against antenna effects (net charge) at manufacture, PIMP diode in 
//   NWELL
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO211HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO211HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO211HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO211HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO211HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO211HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO211HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO211HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C+D)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO21HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO21HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO21HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO21HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO21HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO21HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO21HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO21HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B)+C)
	and	i0 (n_0, A, B);
	or	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO221HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO221HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO221HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO221HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO221HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO221HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO221HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO221HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D)+E)
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0) || (B == 1'b0 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO222HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO222HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO222HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO222HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO222HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO222HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO222HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO222HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A*B)+(C*D)+(E*F))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	and	i2 (n_2, E, F);
	or	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1) || (A == 1'b1 && B == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (F +=> Q) = 
		(0.02, 0.02);
      if ((B == 1'b1 && D == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b0 && D == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO22HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO22HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO22HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO22HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B)+(C*D))
	and	i0 (n_0, A, B);
	and	i1 (n_1, C, D);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO311HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO311HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO311HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO311HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO311HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO311HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO311HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO311HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D+E)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO31HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO31HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO31HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO31HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO31HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO31HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO31HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO31HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A*B*C)+D)
	and	i0 (n_0, A, B, C);
	or	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO321HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO321HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO321HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO321HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO321HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO321HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO321HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO321HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input AND, 2-Input AND into 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E)+F)
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0) || (A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1) || (A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = 
		(0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1) || (B == 1'b0 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b1 && E == 1'b0) || 
		(A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO32HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO32HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO32HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO32HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO32HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO32HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO32HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO32HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input, 2-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b0)) (D +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1) || (A == 1'b1 && B == 1'b0 && C == 1'b1)) (D +=> Q) = 
		(0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && C == 1'b0)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1 && C == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO33HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO33HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO33HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO33HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO33HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO33HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module AO33HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : AO33HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input AND into 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A*B*C)+(D*E*F))
	and	i0 (n_0, A, B, C);
	and	i1 (n_1, D, E, F);
	or	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1 && D == 1'b0 && E == 1'b1 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX1 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX12 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX2 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX3 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX4 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX6 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTHHDX8 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTHHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

// Function Q: A; Tristate function: !E
	bufif1	i0 (Q, A, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX1 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX12 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX2 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX3 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX4 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX6 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BTLHDX8 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BTLHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Buffer with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

// Function Q: A; Tristate function: EN
	bufif0	i0 (Q, A, EN);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX12 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX2 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX3 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX4 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX6 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module BUHDX8 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : BUHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module CAGHDX0 (A, B, CI, CO);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : CAGHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module CAGHDX1 (A, B, CI, CO);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : CAGHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module CAGHDX2 (A, B, CI, CO);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : CAGHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module CAGHDX4 (A, B, CI, CO);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : CAGHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Carry Generator
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module CLKVBUFHD (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : CLKVBUFHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Virtual Clock Tree Buffer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP10HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP10HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP15HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP15HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP25HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP25HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP3HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP3HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP5HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP5HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DECAP7HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DECAP7HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, ESD optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFHDX0 (CN, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFHDX1 (CN, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFHDX2 (CN, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFHDX4 (CN, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFQHDX0 (CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFQHDX1 (CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFQHDX2 (CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFQHDX4 (CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge CN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRHDX0 (CN, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRHDX1 (CN, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRHDX2 (CN, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRHDX4 (CN, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRQHDX0 (CN, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRQHDX1 (CN, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRQHDX2 (CN, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRQHDX4 (CN, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSHDX0 (CN, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSHDX1 (CN, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSHDX2 (CN, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSHDX4 (CN, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, n_2, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSQHDX0 (CN, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSQHDX1 (CN, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSQHDX2 (CN, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFRSQHDX4 (CN, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSHDX0 (CN, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSHDX1 (CN, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSHDX2 (CN, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSHDX4 (CN, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge CN => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSQHDX0 (CN, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSQHDX1 (CN, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSQHDX2 (CN, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFFSQHDX4 (CN, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFFSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_CN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_CN);
	u1_fd5	i1 (IQ, delay_D, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, CN);
	u1_fd5	i1 (IQ, D, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (negedge CN => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR2HDX1 (C, D0, D1, Q0, Q1, QN0, QN1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR2HDX2 (C, D0, D1, Q0, Q1, QN0, QN1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFR8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFR8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRHDX0 (C, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRHDX1 (C, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRHDX2 (C, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRHDX4 (C, D, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ2HDX1 (C, D0, D1, Q0, Q1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ2HDX2 (C, D0, D1, Q0, Q1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ8HDX1 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQ8HDX2 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQ8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, IQN3, 
		delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	u1_fd5	i0 (IQ0, D0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQHDX0 (C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQHDX1 (C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQHDX2 (C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRQHDX4 (C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_D, IQ, IQN;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u1_fd5	i0 (IQ, D, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge C, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR2HDX1 (C, D0, D1, Q0, Q1, QN0, QN1, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR2HDX2 (C, D0, D1, Q0, Q1, QN0, QN1, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	buf	i6 (QN0, IQN0);
	buf	i7 (QN1, IQN1);
	checkrs	i8 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	buf	i12 (QN0, IQN0);
	buf	i13 (QN1, IQN1);
	buf	i14 (QN2, IQN2);
	buf	i15 (QN3, IQN3);
	checkrs	i16 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRR8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRR8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	buf	i24 (QN0, IQN0);
	buf	i25 (QN1, IQN1);
	buf	i26 (QN2, IQN2);
	buf	i27 (QN3, IQN3);
	buf	i28 (QN4, IQN4);
	buf	i29 (QN5, IQN5);
	buf	i30 (QN6, IQN6);
	buf	i31 (QN7, IQN7);
	checkrs	i32 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (posedge C => (QN0 -: D0)) = (0.02, 0.02);
      (posedge C => (QN1 -: D1)) = (0.02, 0.02);
      (posedge C => (QN2 -: D2)) = (0.02, 0.02);
      (posedge C => (QN3 -: D3)) = (0.02, 0.02);
      (posedge C => (QN4 -: D4)) = (0.02, 0.02);
      (posedge C => (QN5 -: D5)) = (0.02, 0.02);
      (posedge C => (QN6 -: D6)) = (0.02, 0.02);
      (posedge C => (QN7 -: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRHDX0 (C, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRHDX1 (C, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRHDX2 (C, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRHDX4 (C, D, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ2HDX1 (C, D0, D1, Q0, Q1, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ2HDX2 (C, D0, D1, Q0, Q1, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    IQ0, IQN0, IQ1, IQN1, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	buf	i4 (Q0, IQ0);
	buf	i5 (Q1, IQ1);
	checkrs	i6 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	buf	i8 (Q0, IQ0);
	buf	i9 (Q1, IQ1);
	buf	i10 (Q2, IQ2);
	buf	i11 (Q3, IQ3);
	checkrs	i12 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ8HDX1 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQ8HDX2 (C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQ8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    delay_C, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7, 
		c_SH_D;

	u1_fd5	i0 (IQ0, delay_D0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, delay_D1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, delay_D2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, delay_D3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, delay_D4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, delay_D5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, delay_D6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, delay_D7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, c_SH_D;

	u1_fd5	i0 (IQ0, D0, C, RN, 1'b1, NOTIFY_REG0);
	not	i1 (IQN0, IQ0);
	u1_fd5	i2 (IQ1, D1, C, RN, 1'b1, NOTIFY_REG1);
	not	i3 (IQN1, IQ1);
	u1_fd5	i4 (IQ2, D2, C, RN, 1'b1, NOTIFY_REG2);
	not	i5 (IQN2, IQ2);
	u1_fd5	i6 (IQ3, D3, C, RN, 1'b1, NOTIFY_REG3);
	not	i7 (IQN3, IQ3);
	u1_fd5	i8 (IQ4, D4, C, RN, 1'b1, NOTIFY_REG4);
	not	i9 (IQN4, IQ4);
	u1_fd5	i10 (IQ5, D5, C, RN, 1'b1, NOTIFY_REG5);
	not	i11 (IQN5, IQ5);
	u1_fd5	i12 (IQ6, D6, C, RN, 1'b1, NOTIFY_REG6);
	not	i13 (IQN6, IQ6);
	u1_fd5	i14 (IQ7, D7, C, RN, 1'b1, NOTIFY_REG7);
	not	i15 (IQN7, IQ7);
	buf	i16 (Q0, IQ0);
	buf	i17 (Q1, IQ1);
	buf	i18 (Q2, IQ2);
	buf	i19 (Q3, IQ3);
	buf	i20 (Q4, IQ4);
	buf	i21 (Q5, IQ5);
	buf	i22 (Q6, IQ6);
	buf	i23 (Q7, IQ7);
	checkrs	i24 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q0 +: D0)) = (0.02, 0.02);
      (posedge C => (Q1 +: D1)) = (0.02, 0.02);
      (posedge C => (Q2 +: D2)) = (0.02, 0.02);
      (posedge C => (Q3 +: D3)) = (0.02, 0.02);
      (posedge C => (Q4 +: D4)) = (0.02, 0.02);
      (posedge C => (Q5 +: D5)) = (0.02, 0.02);
      (posedge C => (Q6 +: D6)) = (0.02, 0.02);
      (posedge C => (Q7 +: D7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQHDX0 (C, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQHDX1 (C, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQHDX2 (C, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRQHDX4 (C, D, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSHDX0 (C, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSHDX1 (C, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSHDX2 (C, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSHDX4 (C, D, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, delay_SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (n_1, IQ);
	and	i2 (IQN, n_1, SN);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSQHDX0 (C, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSQHDX1 (C, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSQHDX2 (C, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRRSQHDX4 (C, D, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, RN, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSHDX0 (C, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSHDX1 (C, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSHDX2 (C, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSHDX4 (C, D, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (posedge C => (QN -: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSQHDX0 (C, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSQHDX1 (C, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSQHDX2 (C, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DFRSQHDX4 (C, D, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DFRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_C, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, delay_D, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u1_fd5	i0 (IQ, D, C, 1'b1, SN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (posedge C => (Q +: D)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHHDX0 (D, G, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHHDX1 (D, G, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHHDX2 (D, G, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHHDX4 (D, G, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHQHDX0 (D, G, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHQHDX1 (D, G, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHQHDX2 (D, G, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHQHDX4 (D, G, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRHDX0 (D, G, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRHDX1 (D, G, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRHDX2 (D, G, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRHDX4 (D, G, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRQHDX0 (D, G, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRQHDX1 (D, G, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRQHDX2 (D, G, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRQHDX4 (D, G, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSHDX0 (D, G, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSHDX1 (D, G, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSHDX2 (D, G, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSHDX4 (D, G, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSQHDX0 (D, G, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSQHDX1 (D, G, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSQHDX2 (D, G, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRSQHDX4 (D, G, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, delay_D, delay_G, delay_SN, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld6	i0 (IQ, D, G, SN, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHRTHDX1 (D, EN, G, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHRTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with reset; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, G, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_RN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, delay_RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, 1'b1, RN, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSHDX0 (D, G, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSHDX1 (D, G, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSHDX2 (D, G, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSHDX4 (D, G, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	buf	i3 (QN, IQN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (posedge G => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSQHDX0 (D, G, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSQHDX1 (D, G, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSQHDX2 (D, G, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSQHDX4 (D, G, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	buf	i2 (Q, IQ);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHSTHDX1 (D, EN, G, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHSTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch with set; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, G, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_SN, delay_D, IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, delay_D, delay_G, delay_SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_G);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN, c_SH_D;

	u_ld5	i0 (IQ, D, G, SN, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);
	checkrs	i3 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(negedge G &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge G, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLHTHDX1 (D, EN, G, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLHTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : high active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, G;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_G, delay_D, IQ, IQN;

	u_ld5	i0 (IQ, delay_D, delay_G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_G, delay_D);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, IQN;

	u_ld5	i0 (IQ, D, G, 1'b1, 1'b1, NOTIFY_REG);
	not	i1 (IQN, IQ);
	bufif0	i2 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (posedge G => (Q +: D)) = (0.02, 0.02);

	$setuphold(negedge G, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge G, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(posedge G, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLHDX0 (D, GN, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLHDX1 (D, GN, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLHDX2 (D, GN, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLHDX4 (D, GN, Q, QN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLQHDX0 (D, GN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLQHDX1 (D, GN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLQHDX2 (D, GN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLQHDX4 (D, GN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRHDX0 (D, GN, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRHDX1 (D, GN, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRHDX2 (D, GN, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRHDX4 (D, GN, Q, QN, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRQHDX0 (D, GN, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRQHDX1 (D, GN, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRQHDX2 (D, GN, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRQHDX4 (D, GN, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSHDX0 (D, GN, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSHDX1 (D, GN, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSHDX2 (D, GN, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSHDX4 (D, GN, Q, QN, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (RN -=> QN) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSQHDX0 (D, GN, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSQHDX1 (D, GN, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSQHDX2 (D, GN, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRSQHDX4 (D, GN, Q, RN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set and reset
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, RN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld6	i1 (IQ, delay_D, clock_i, delay_SN, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, delay_RN, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld6	i1 (IQ, D, clock_i, SN, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, RN, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRT2HDX1 (D0, D1, EN, GN, Q0, Q1, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRT2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, EN, GN, RN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);
	checkrs	i7 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);
	checkrs	i7 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRT4HDX1 (D0, D1, D2, D3, EN, GN, Q0, Q1, Q2, Q3, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRT4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, D2, D3, EN, GN, RN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, 
		delay_D3, IQ3, IQN3, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, delay_RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, delay_RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);
	checkrs	i13 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);
	checkrs	i13 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRT8HDX1 (D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRT8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit low active transparent D-latch with reset; tristate Q Buffer with active low 
//   enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, RN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, delay_GN, delay_RN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, 
		delay_D3, IQ3, IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7,
		 IQ7, IQN7, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, delay_RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, delay_RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, delay_RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, delay_RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, delay_D4, clock_i, 1'b1, delay_RN, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, delay_D5, clock_i, 1'b1, delay_RN, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, delay_D6, clock_i, 1'b1, delay_RN, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, delay_D7, clock_i, 1'b1, delay_RN, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);
	checkrs	i25 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);
      (RN +=> Q4) = (0.02, 0.02);
      (RN +=> Q5) = (0.02, 0.02);
      (RN +=> Q6) = (0.02, 0.02);
      (RN +=> Q7) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$setuphold(posedge GN &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_GN);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7, 
		c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, RN, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, RN, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, RN, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, RN, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, D4, clock_i, 1'b1, RN, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, D5, clock_i, 1'b1, RN, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, D6, clock_i, 1'b1, RN, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, D7, clock_i, 1'b1, RN, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);
	checkrs	i25 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);
      (RN +=> Q0) = (0.02, 0.02);
      (RN +=> Q1) = (0.02, 0.02);
      (RN +=> Q2) = (0.02, 0.02);
      (RN +=> Q3) = (0.02, 0.02);
      (RN +=> Q4) = (0.02, 0.02);
      (RN +=> Q5) = (0.02, 0.02);
      (RN +=> Q6) = (0.02, 0.02);
      (RN +=> Q7) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge GN &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLRTHDX1 (D, EN, GN, Q, RN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLRTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with reset; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, GN, RN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_RN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, delay_RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, delay_RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, RN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, RN, 1'b1);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSHDX0 (D, GN, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSHDX1 (D, GN, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSHDX2 (D, GN, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSHDX4 (D, GN, Q, QN, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (D -=> QN) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (negedge GN => (QN -: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSQHDX0 (D, GN, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSQHDX1 (D, GN, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSQHDX2 (D, GN, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSQHDX4 (D, GN, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active single Q transparent D-latch with set
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLSTHDX1 (D, EN, GN, Q, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLSTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch with set; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, GN, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_SN, delay_D, IQ, IQN, c_SH_D;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, delay_SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, 1'b1, delay_SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_GN);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN, c_SH_D;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, SN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);
	checkrs	i4 (c_SH_D, 1'b1, SN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);
      (SN -=> Q) = (0.02, 0.02);

	$setuphold(posedge GN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge GN, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLT2HDX1 (D0, D1, EN, GN, Q0, Q1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLT2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, EN, GN;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	bufif0	i5 (Q0, IQ0, EN);
	bufif0	i6 (Q1, IQ1, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLT4HDX1 (D0, D1, D2, D3, EN, GN, Q0, Q1, Q2, Q3);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLT4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, D2, D3, EN, GN;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	bufif0	i9 (Q0, IQ0, EN);
	bufif0	i10 (Q1, IQ1, EN);
	bufif0	i11 (Q2, IQ2, EN);
	bufif0	i12 (Q3, IQ3, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLT8HDX1 (D0, D1, D2, D3, D4, D5, D6, D7, EN, GN, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLT8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D0, D1, D2, D3, D4, D5, D6, D7, EN, GN;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, delay_GN, delay_D0, IQ0, IQN0, delay_D1, IQ1, IQN1, delay_D2, IQ2, IQN2, delay_D3, IQ3, 
		IQN3, delay_D4, IQ4, IQN4, delay_D5, IQ5, IQN5, delay_D6, IQ6, IQN6, delay_D7, IQ7, IQN7;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ0, delay_D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, delay_D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, delay_D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, delay_D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, delay_D4, clock_i, 1'b1, 1'b1, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, delay_D5, clock_i, 1'b1, 1'b1, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, delay_D6, clock_i, 1'b1, 1'b1, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, delay_D7, clock_i, 1'b1, 1'b1, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_GN, delay_D0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_GN, delay_D1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_GN, delay_D2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_GN, delay_D3);
	$setuphold(posedge GN, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_GN, delay_D4);
	$setuphold(posedge GN, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_GN, delay_D5);
	$setuphold(posedge GN, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_GN, delay_D6);
	$setuphold(posedge GN, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$setuphold(posedge GN, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_GN, delay_D7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    clock_i, IQ0, IQN0, IQ1, IQN1, IQ2, IQN2, IQ3, IQN3, IQ4, IQN4, IQ5, IQN5, IQ6, IQN6, IQ7, IQN7;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ0, D0, clock_i, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_ld5	i3 (IQ1, D1, clock_i, 1'b1, 1'b1, NOTIFY_REG1);
	not	i4 (IQN1, IQ1);
	u_ld5	i5 (IQ2, D2, clock_i, 1'b1, 1'b1, NOTIFY_REG2);
	not	i6 (IQN2, IQ2);
	u_ld5	i7 (IQ3, D3, clock_i, 1'b1, 1'b1, NOTIFY_REG3);
	not	i8 (IQN3, IQ3);
	u_ld5	i9 (IQ4, D4, clock_i, 1'b1, 1'b1, NOTIFY_REG4);
	not	i10 (IQN4, IQ4);
	u_ld5	i11 (IQ5, D5, clock_i, 1'b1, 1'b1, NOTIFY_REG5);
	not	i12 (IQN5, IQ5);
	u_ld5	i13 (IQ6, D6, clock_i, 1'b1, 1'b1, NOTIFY_REG6);
	not	i14 (IQN6, IQ6);
	u_ld5	i15 (IQ7, D7, clock_i, 1'b1, 1'b1, NOTIFY_REG7);
	not	i16 (IQN7, IQ7);
	bufif0	i17 (Q0, IQ0, EN);
	bufif0	i18 (Q1, IQ1, EN);
	bufif0	i19 (Q2, IQ2, EN);
	bufif0	i20 (Q3, IQ3, EN);
	bufif0	i21 (Q4, IQ4, EN);
	bufif0	i22 (Q5, IQ5, EN);
	bufif0	i23 (Q6, IQ6, EN);
	bufif0	i24 (Q7, IQ7, EN);

// timing section:
   specify
      (D0 +=> Q0) = (0.02, 0.02);
      (D1 +=> Q1) = (0.02, 0.02);
      (D2 +=> Q2) = (0.02, 0.02);
      (D3 +=> Q3) = (0.02, 0.02);
      (D4 +=> Q4) = (0.02, 0.02);
      (D5 +=> Q5) = (0.02, 0.02);
      (D6 +=> Q6) = (0.02, 0.02);
      (D7 +=> Q7) = (0.02, 0.02);
      (EN => Q0) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q1) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q2) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q3) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q4) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q5) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q6) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (EN => Q7) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q0 +: D0)) = (0.02, 0.02);
      (negedge GN => (Q1 +: D1)) = (0.02, 0.02);
      (negedge GN => (Q2 +: D2)) = (0.02, 0.02);
      (negedge GN => (Q3 +: D3)) = (0.02, 0.02);
      (negedge GN => (Q4 +: D4)) = (0.02, 0.02);
      (negedge GN => (Q5 +: D5)) = (0.02, 0.02);
      (negedge GN => (Q6 +: D6)) = (0.02, 0.02);
      (negedge GN => (Q7 +: D7)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge GN, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge GN, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge GN, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge GN, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge GN, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge GN, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge GN, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge GN, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$width(negedge GN, 0.02, 0, NOTIFY_REG0);
	$width(negedge GN, 0.02, 0, NOTIFY_REG1);
	$width(negedge GN, 0.02, 0, NOTIFY_REG2);
	$width(negedge GN, 0.02, 0, NOTIFY_REG3);
	$width(negedge GN, 0.02, 0, NOTIFY_REG4);
	$width(negedge GN, 0.02, 0, NOTIFY_REG5);
	$width(negedge GN, 0.02, 0, NOTIFY_REG6);
	$width(negedge GN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLLTHDX1 (D, EN, GN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLLTHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : low active transparent D-latch; tristate Q Buffer with active low enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     D, EN, GN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, delay_GN, delay_D, IQ, IQN;

	not	i0 (clock_i, delay_GN);
	u_ld5	i1 (IQ, delay_D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_GN, delay_D);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    clock_i, IQ, IQN;

	not	i0 (clock_i, GN);
	u_ld5	i1 (IQ, D, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	bufif0	i3 (Q, IQ, EN);

// timing section:
   specify
      (D +=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
      (negedge GN => (Q +: D)) = (0.02, 0.02);

	$setuphold(posedge GN, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge GN, negedge D, 0.02, 0.02, NOTIFY_REG);
	$width(negedge GN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY1HDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.78, 0.65);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY1HDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 1ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.82, 0.81);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY2HDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (1.65, 1.39);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY2HDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 2ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (1.73, 1.71);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY4HDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (3.27, 2.87);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY4HDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 4ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (3.43, 3.45);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY8HDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY8HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (6.91, 7.02);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module DLY8HDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : DLY8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Delay Cell 8ns
//                    : Note: used for the different technology modules 
//                            and for the different operating conditions
//                            the cell name does not express a related 
//                            cell delay as nanosecond-value.
//                            The exact cell delay has to be timing 
//                            analyzed at the choosen operating 
//                            conditions and with the backannotated
//                            routing parasitics.
//
//   last modified by : XLIB_PROC generated
//*****************************************************************

   input     A;
   output    Q;

// Function Q: A
   buf       i0  (Q, A);

// timing section:
   specify
      (A +=> Q) = (7.08, 7.48);
   endspecify


endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A^B)
	xnor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EN3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EN3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XNOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A^B^C)
	xnor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A^B)
	xor	i0 (Q, A, B);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b1)) (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module EO3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : EO3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input XOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A^B^C)
	xor	i0 (Q, A, B, C);

// timing section:
   specify
      (posedge A => (Q -: Q)) = (0.02, 0.02);
      (negedge A => (Q -: Q)) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1) || (B == 1'b1 && C == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (posedge B => (Q -: Q)) = (0.02, 0.02);
      (negedge B => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b0)) (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && C == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge C => (Q -: Q)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0)) (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FAHDX0 (A, B, CI, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FAHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FAHDX1 (A, B, CI, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FAHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FAHDX2 (A, B, CI, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FAHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FAHDX4 (A, B, CI, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FAHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Full Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, CI;
   output    CO, S;

// logic section:

	wire    n_0, n_1, n_2;

// Function CO: (B*CI) + (A*CI) + (A*B)
	and	i0 (n_0, B, CI);
	and	i1 (n_1, A, CI);
	and	i2 (n_2, A, B);
	or	i3 (CO, n_0, n_1, n_2);

// Function S: (A^B^CI)
	xor	i4 (S, A, B, CI);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if (((B == 1'b0 && CI == 1'b0))) (A +=> S) = (0.02, 0.02);
      if ((B == 1'b1 && CI == 1'b0)) (A -=> S) = (0.02, 0.02);
      if (((B == 1'b1 && CI == 1'b1))) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && CI == 1'b0)) (B +=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b0)) (B -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && CI == 1'b1)) (B +=> S) = (0.02, 0.02);
      (CI +=> CO) = (0.02, 0.02);
      (posedge CI => (S -: S)) = (0.02, 0.02);
      (negedge CI => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0)) (CI +=> S) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (CI -=> S) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b1)) (CI +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE10HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE10HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE11HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE11HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE12HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE12HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE13HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE13HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE14HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE14HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE15HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE15HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE16HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE16HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE17HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE17HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE18HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE18HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE19HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE19HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE20HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE20HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE21HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE21HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE22HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE22HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE23HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE23HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE24HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE24HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE25HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE25HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE26HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE26HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE27HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE27HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE28HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE28HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE29HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE29HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE2HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE2HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE30HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE30HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE31HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE31HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE32HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE32HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE3HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE3HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE4HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE4HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE5HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE5HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE6HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE6HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE7HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE7HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE8HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE8HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNE9HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNE9HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED10HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED10HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED11HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED11HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED12HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED12HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED13HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED13HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED14HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED14HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED15HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED15HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED16HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED16HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED17HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED17HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED18HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED18HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED19HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED19HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED20HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED20HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED21HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED21HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED22HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED22HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED23HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED23HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED24HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED24HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED25HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED25HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED26HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED26HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED27HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED27HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED28HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED28HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED29HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED29HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED30HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED30HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED31HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED31HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED32HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED32HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED5HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED5HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED6HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED6HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED7HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED7HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED8HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED8HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FCNED9HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FCNED9HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell with buffering capacitance, built on NE transistor, double cell height
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED10HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED10HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED15HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED15HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED1HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED1HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED25HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED25HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED2HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED2HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED3HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED3HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED5HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED5HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module FEED7HD ();
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : FEED7HD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Filler cell
//   last modified by : XLIB_PROC generated
//****************************************************************************

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module HAHDX0 (A, B, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : HAHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module HAHDX1 (A, B, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : HAHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module HAHDX2 (A, B, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : HAHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module HAHDX4 (A, B, CO, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : HAHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Half Adder
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    CO, S;

// logic section:

// Function CO: (A*B)
	and	i0 (CO, A, B);

// Function S: (A^B)
	xor	i1 (S, A, B);

// timing section:
   specify
      (A +=> CO) = (0.02, 0.02);
      (posedge A => (S -: S)) = (0.02, 0.02);
      (negedge A => (S -: S)) = (0.02, 0.02);
      if ((B == 1'b0)) (A +=> S) = (0.02, 0.02);
      (B +=> CO) = (0.02, 0.02);
      (posedge B => (S -: S)) = (0.02, 0.02);
      (negedge B => (S -: S)) = (0.02, 0.02);
      if ((A == 1'b0)) (B +=> S) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX12 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX2 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX3 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX4 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX6 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module INHDX8 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : INHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Inverter
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: !(A)
	not	i0 (Q, A);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX1 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX12 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX2 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX3 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX4 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX6 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITHHDX8 (A, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITHHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active high Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: !E
	not	i0 (n_0, A);
	bufif1	i1 (Q, n_0, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (E => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX1 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX12 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX12
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX2 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX3 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX3
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX4 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX6 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX6
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ITLHDX8 (A, EN, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ITLHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Tristate Inverter with active low Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, EN;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(A); Tristate function: EN
	not	i0 (n_0, A);
	bufif0	i1 (Q, n_0, EN);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (EN => Q) = (0.02, 0.02, 0.02, 0.02, 0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCNHDX0 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCNHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCNHDX1 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCNHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCNHDX2 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCNHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCNHDX4 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCNHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_1;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, delay_CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_1;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	not	i1 (n_1, IQ);
	or	i2 (GCLK, CLK, n_1);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCPHDX0 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCPHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCPHDX1 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCPHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCPHDX2 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCPHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LGCPHDX4 (CLK, E, GCLK);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LGCPHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, delay_CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	and	i2 (GCLK, CLK, IQ);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LOGIC0DHD (Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LOGIC0DHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Constant logic 0, DfM optimized, cross-talk optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

   output    Q;

// logic section:

// Function Q: 0
	buf	i0 (Q, 1'b0);

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LOGIC0LVHD (Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LOGIC0LVHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Constant logic 0, DfM optimized, cross-talk optimized for LV range
//   last modified by : XLIB_PROC generated
//****************************************************************************

   output    Q;

// logic section:

// Function Q: 0
	buf	i0 (Q, 1'b0);

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LOGIC1DHD (Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LOGIC1DHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Constant logic 1, DfM optimized, cross-talk optimized
//   last modified by : XLIB_PROC generated
//****************************************************************************

   output    Q;

// logic section:

// Function Q: 1
	buf	i0 (Q, 1'b1);

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LOGIC1LVHD (Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LOGIC1LVHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Constant logic 1, DfM optimized, cross-talk optimized for LV range
//   last modified by : XLIB_PROC generated
//****************************************************************************

   output    Q;

// logic section:

// Function Q: 1
	buf	i0 (Q, 1'b1);

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCNHDX0 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCNHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCNHDX1 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCNHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCNHDX2 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCNHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCNHDX4 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCNHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, delay_E, delay_SE);
	u_ld1	i1 (IQ, dat_i, delay_CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, delay_CLK, n_2);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, n_2, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	or	i0 (dat_i, E, SE);
	u_ld1	i1 (IQ, dat_i, CLK, NOTIFY_REG);
	not	i2 (n_2, IQ);
	or	i3 (GCLK, CLK, n_2);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCPHDX0 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCPHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCPHDX1 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCPHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCPHDX2 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCPHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSGCPHDX4 (CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSGCPHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan precontrol
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, delay_SE, IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, delay_CLK);
	or	i1 (dat_i, delay_E, delay_SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, delay_CLK, IQ);
	not	i4 (c_SH_E, delay_SE);
	not	i5 (c_SH_SE, delay_E);
	not #(0.01)	i6 (c_SH_E_v, delay_SE);
	not #(0.01)	i7 (c_SH_SE_v, delay_E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_SE);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, dat_i, clock_i, c_SH_E, c_SH_SE, c_SH_E_v, c_SH_SE_v;

	not	i0 (clock_i, CLK);
	or	i1 (dat_i, E, SE);
	u_ld1	i2 (IQ, dat_i, clock_i, NOTIFY_REG);
	and	i3 (GCLK, CLK, IQ);
	not	i4 (c_SH_E, SE);
	not	i5 (c_SH_SE, E);
	not #(0.01)	i6 (c_SH_E_v, SE);
	not #(0.01)	i7 (c_SH_SE_v, E);

// timing section:
   specify
      (CLK +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E &&& c_SH_E_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E &&& c_SH_E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, posedge SE &&& c_SH_SE_v, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge SE &&& c_SH_SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCNHDX0 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCNHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCNHDX1 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCNHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCNHDX2 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCNHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCNHDX4 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCNHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge clock gating cell, high latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, n_2;

	u_ld1	i0 (IQ, delay_E, delay_CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, delay_CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, n_2;

	u_ld1	i0 (IQ, E, CLK, NOTIFY_REG);
	buf	i1 (CGOBS, IQ);
	nor	i2 (n_2, IQ, SE);
	or	i3 (GCLK, CLK, n_2);

// timing section:
   specify
      (posedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE -=> GCLK) = (0.02, 0.02);

	$setuphold(negedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCPHDX0 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCPHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCPHDX1 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCPHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCPHDX2 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCPHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module LSOGCPHDX4 (CGOBS, CLK, E, GCLK, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : LSOGCPHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge clock gating cell, low latch Enable, scan postcontrol, obs_output
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CLK, E, SE;
   output    CGOBS, GCLK;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    delay_CLK, delay_E, IQ, clock_i, n_3;

	not	i0 (clock_i, delay_CLK);
	u_ld1	i1 (IQ, delay_E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, delay_CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG,,, delay_CLK, delay_E);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    IQ, clock_i, n_3;

	not	i0 (clock_i, CLK);
	u_ld1	i1 (IQ, E, clock_i, NOTIFY_REG);
	buf	i2 (CGOBS, IQ);
	or	i3 (n_3, IQ, SE);
	and	i4 (GCLK, CLK, n_3);

// timing section:
   specify
      (negedge CLK => (CGOBS +: E)) = (0.02, 0.02);
      (CLK +=> GCLK) = (0.02, 0.02);
      (E +=> CGOBS) = (0.02, 0.02);
      (SE +=> GCLK) = (0.02, 0.02);

	$setuphold(posedge CLK, posedge E, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge CLK, negedge E, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CLK, 0.02, 0, NOTIFY_REG);
	$width(negedge CLK, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MPROBEBUHDX8 (A);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MPROBEBUHDX8
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Microprobe cell for buffered signal output (signal decoupling)
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MPROBEHD (A);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MPROBEHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Micro probe cell for direct wire access
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;

// logic section:

// timing section:
   specify
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2HDX0 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2HDX1 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2HDX2 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2HDX4 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

// Function Q: (!S*IN0)+(S*IN1)
	u_mx2	i0 (Q, IN0, IN1, S);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2IHDX0 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2IHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2IHDX1 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2IHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2IHDX2 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2IHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU2IHDX4 (IN0, IN1, Q, S);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU2IHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, S;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((!S*IN0)+(S*IN1))
	u_mx2	i0 (n_0, IN0, IN1, S);
	not	i1 (Q, n_0);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (posedge S => (Q -: Q)) = (0.02, 0.02);
      (negedge S => (Q -: Q)) = (0.02, 0.02);
      if ((IN0 == 1'b0 && IN1 == 1'b1)) (S -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4HDX0 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4HDX1 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4HDX2 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4HDX4 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: (IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (Q, n_0, n_1, S1);

// timing section:
   specify
      (IN0 +=> Q) = (0.02, 0.02);
      (IN1 +=> Q) = (0.02, 0.02);
      (IN2 +=> Q) = (0.02, 0.02);
      (IN3 +=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4IHDX0 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4IHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4IHDX1 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4IHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4IHDX2 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4IHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module MU4IHDX4 (IN0, IN1, IN2, IN3, Q, S0, S1);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : MU4IHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4:1 inverting Multiplexer
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     IN0, IN1, IN2, IN3, S0, S1;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((IN0*(!S0*!S1))+(IN1*(S0*!S1))+(IN2*(!S0*S1))+(IN3*(S0*S1)))
	u_mx2	i0 (n_0, IN0, IN1, S0);
	u_mx2	i1 (n_1, IN2, IN3, S0);
	u_mx2	i2 (n_2, n_0, n_1, S1);
	not	i3 (Q, n_2);

// timing section:
   specify
      (IN0 -=> Q) = (0.02, 0.02);
      (IN1 -=> Q) = (0.02, 0.02);
      (IN2 -=> Q) = (0.02, 0.02);
      (IN3 -=> Q) = (0.02, 0.02);
      (posedge S0 => (Q -: Q)) = (0.02, 0.02);
      (negedge S0 => (Q -: Q)) = (0.02, 0.02);
      (posedge S1 => (Q -: Q)) = (0.02, 0.02);
      (negedge S1 => (Q -: Q)) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA22HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA22HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA22HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA22HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A*B)*C)
	nand	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A*B)
	nand	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2I1HDX0 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2I1HDX1 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2I1HDX2 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA2I1HDX4 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA2I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A*B*C)
	nand	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I1HDX0 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I1HDX1 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I1HDX2 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I1HDX4 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I2HDX0 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I2HDX1 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I2HDX2 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA3I2HDX4 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA3I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NAND with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D)
	nand	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I1HDX0 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I1HDX1 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I1HDX2 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I1HDX4 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I2HDX0 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I2HDX1 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I2HDX2 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I2HDX4 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I3HDX0 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I3HDX1 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I3HDX2 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA4I3HDX4 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA4I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E)
	nand	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I1HDX0 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I1HDX1 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I1HDX2 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I1HDX4 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I2HDX0 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I2HDX1 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I2HDX2 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I2HDX4 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I3HDX0 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I3HDX1 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I3HDX2 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I3HDX4 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I4HDX0 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I4HDX1 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I4HDX2 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA5I4HDX4 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA5I4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A*B*C*D*E*F)
	nand	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I1HDX0 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I1HDX1 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I1HDX2 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I1HDX4 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN*B*C*D*E*F)
	not	i0 (n_0, AN);
	nand	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I2HDX0 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I2HDX1 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I2HDX2 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I2HDX4 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN*!BN*C*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nand	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I3HDX0 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I3HDX1 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I3HDX2 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I3HDX4 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN*!BN*!CN*D*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nand	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I4HDX0 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I4HDX1 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I4HDX2 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I4HDX4 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN*!BN*!CN*!DN*E*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nand	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I5HDX0 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I5HDX1 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I5HDX2 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NA6I5HDX4 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NA6I5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NAND with 5 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN*!BN*!CN*!DN*!EN*F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nand	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO22HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO22HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO22HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO22HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR into 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!(A+B)+C)
	nor	i0 (n_0, A, B);
	nor	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: !(A+B)
	nor	i0 (Q, A, B);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2I1HDX0 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2I1HDX1 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2I1HDX2 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO2I1HDX4 (AN, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO2I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: !(A+B+C)
	nor	i0 (Q, A, B, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I1HDX0 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I1HDX1 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I1HDX2 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I1HDX4 (AN, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I2HDX0 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I2HDX1 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I2HDX2 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO3I2HDX4 (AN, BN, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO3I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D)
	nor	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I1HDX0 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I1HDX1 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I1HDX2 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I1HDX4 (AN, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I2HDX0 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I2HDX1 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I2HDX2 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I2HDX4 (AN, BN, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I3HDX0 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I3HDX1 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I3HDX2 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO4I3HDX4 (AN, BN, CN, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO4I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input NOR with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E)
	nor	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I1HDX0 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I1HDX1 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I1HDX2 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I1HDX4 (AN, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I2HDX0 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I2HDX1 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I2HDX2 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I2HDX4 (AN, BN, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 2 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I3HDX0 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I3HDX1 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I3HDX2 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I3HDX4 (AN, BN, CN, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NAND with 3 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I4HDX0 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I4HDX1 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I4HDX2 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO5I4HDX4 (AN, BN, CN, DN, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO5I4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input NOR with 4 inverted inputs
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: !(A+B+C+D+E+F)
	nor	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I1HDX0 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I1HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I1HDX1 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I1HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I1HDX2 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I1HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I1HDX4 (AN, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I1HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 1 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !(!AN+B+C+D+E+F)
	not	i0 (n_0, AN);
	nor	i1 (Q, n_0, B, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I2HDX0 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I2HDX1 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I2HDX2 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I2HDX4 (AN, BN, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 2 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !(!AN+!BN+C+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	nor	i2 (Q, n_0, n_1, C, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I3HDX0 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I3HDX1 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I3HDX2 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I3HDX4 (AN, BN, CN, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 3 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !(!AN+!BN+!CN+D+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	nor	i3 (Q, n_0, n_1, n_2, D, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I4HDX0 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I4HDX1 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I4HDX2 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I4HDX4 (AN, BN, CN, DN, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 4 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3;

// Function Q: !(!AN+!BN+!CN+!DN+E+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	nor	i4 (Q, n_0, n_1, n_2, n_3, E, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I5HDX0 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I5HDX1 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I5HDX2 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module NO6I5HDX4 (AN, BN, CN, DN, EN, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : NO6I5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input NOR with 5 inverted input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     AN, BN, CN, DN, EN, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2, n_3, n_4;

// Function Q: !(!AN+!BN+!CN+!DN+!EN+F)
	not	i0 (n_0, AN);
	not	i1 (n_1, BN);
	not	i2 (n_2, CN);
	not	i3 (n_3, DN);
	not	i4 (n_4, EN);
	nor	i5 (Q, n_0, n_1, n_2, n_3, n_4, F);

// timing section:
   specify
      (AN +=> Q) = (0.02, 0.02);
      (BN +=> Q) = (0.02, 0.02);
      (CN +=> Q) = (0.02, 0.02);
      (DN +=> Q) = (0.02, 0.02);
      (EN +=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA211HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA211HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA211HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA211HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA211HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA211HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA211HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA211HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C*D)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA21HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA21HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA21HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA21HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA21HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA21HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA21HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA21HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B)*C)
	or	i0 (n_0, A, B);
	and	i1 (Q, n_0, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA221HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA221HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA221HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA221HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA221HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA221HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA221HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA221HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E +=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA222HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA222HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA222HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA222HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA222HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA222HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA222HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA222HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: ((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	and	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA22HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA22HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA22HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA22HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA311HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA311HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA311HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA311HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA311HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA311HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA311HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA311HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA31HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA31HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA31HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA31HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA31HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA31HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA31HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA31HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: ((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	and	i1 (Q, n_0, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA321HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA321HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA321HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA321HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA321HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA321HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA321HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA321HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F +=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F +=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA32HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA32HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA32HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA32HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA32HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA32HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA32HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA32HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA33HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA33HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA33HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA33HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA33HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA33HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OA33HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OA33HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input AND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: ((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	and	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON211HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON211HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON211HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON211HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON211HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON211HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON211HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON211HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C*D)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON21HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON21HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON21HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON21HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON21HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON21HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON21HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON21HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B)*C)
	or	i0 (n_0, A, B);
	nand	i1 (Q, n_0, C);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON221HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON221HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON221HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON221HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON221HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON221HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON221HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON221HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D)*E)
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0 && E == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && D == 1'b1) || (A == 1'b1 && B == 1'b1 && C == 1'b1 && D == 1'b0)) (E -=> Q) = 
		(0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b1 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON222HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON222HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON222HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON222HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON222HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON222HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON222HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON222HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3x2 Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1, n_2;

// Function Q: !((A+B)*(C+D)*(E+F))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	or	i2 (n_2, E, F);
	nand	i3 (Q, n_0, n_1, n_2);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b1 && D == 1'b0 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && D == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b1 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON22HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON22HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON22HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON22HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON22HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON22HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON22HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON22HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B)*(C+D))
	or	i0 (n_0, A, B);
	or	i1 (n_1, C, D);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b1)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON311HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON311HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON311HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON311HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON311HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON311HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON311HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON311HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D*E)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D, E);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b1)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON31HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON31HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON31HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON31HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON31HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON31HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON31HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON31HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

	wire    n_0;

// Function Q: !((A+B+C)*D)
	or	i0 (n_0, A, B, C);
	nand	i1 (Q, n_0, D);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0)) (D -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON321HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON321HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON321HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON321HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON321HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON321HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON321HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON321HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 3-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E)*F)
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1, F);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && D == 1'b1 && E == 1'b0 && F == 1'b1)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b1)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b1)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b1 && C == 1'b0 && E == 1'b1) || 
		(A == 1'b0 && B == 1'b0 && C == 1'b1 && E == 1'b0) || (C == 1'b1 && D == 1'b1 && E == 1'b0)) 
		(F -=> Q) = (0.02, 0.02);
      if ((B == 1'b1 && C == 1'b0 && D == 1'b1 && E == 1'b0) || 
		(B == 1'b0 && C == 1'b0 && D == 1'b0 && E == 1'b1)) (F -=> Q) = (0.02, 0.02);
      if ((A == 1'b1 && B == 1'b0 && C == 1'b0 && D == 1'b1 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON32HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON32HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON32HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON32HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON32HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON32HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON32HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON32HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR, 2-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0)) (E -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON33HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON33HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON33HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON33HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON33HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON33HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module ON33HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : ON33HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2x3-Input OR into 2-Input NAND
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

	wire    n_0, n_1;

// Function Q: !((A+B+C)*(D+E+F))
	or	i0 (n_0, A, B, C);
	or	i1 (n_1, D, E, F);
	nand	i2 (Q, n_0, n_1);

// timing section:
   specify
      (A -=> Q) = (0.02, 0.02);
      if ((B == 1'b0 && C == 1'b0 && F == 1'b0)) (A -=> Q) = (0.02, 0.02);
      (B -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && C == 1'b0 && F == 1'b0)) (B -=> Q) = (0.02, 0.02);
      (C -=> Q) = (0.02, 0.02);
      if ((A == 1'b0 && B == 1'b0 && F == 1'b0)) (C -=> Q) = (0.02, 0.02);
      (D -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && E == 1'b0 && F == 1'b0)) (D -=> Q) = (0.02, 0.02);
      (E -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && F == 1'b0)) (E -=> Q) = (0.02, 0.02);
      (F -=> Q) = (0.02, 0.02);
      if ((C == 1'b0 && D == 1'b0 && E == 1'b0)) (F -=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR2HDX0 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR2HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR2HDX1 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR2HDX2 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR2HDX4 (A, B, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR2HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B;
   output    Q;

// logic section:

// Function Q: (A+B)
	or	i0 (Q, A, B);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR3HDX0 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR3HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR3HDX1 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR3HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR3HDX2 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR3HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR3HDX4 (A, B, C, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR3HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 3-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C;
   output    Q;

// logic section:

// Function Q: (A+B+C)
	or	i0 (Q, A, B, C);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR4HDX0 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR4HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR4HDX1 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR4HDX2 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR4HDX4 (A, B, C, D, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR4HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D;
   output    Q;

// logic section:

// Function Q: (A+B+C+D)
	or	i0 (Q, A, B, C, D);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR5HDX0 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR5HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR5HDX1 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR5HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR5HDX2 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR5HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR5HDX4 (A, B, C, D, E, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR5HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 5-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E)
	or	i0 (Q, A, B, C, D, E);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR6HDX0 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR6HDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR6HDX1 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR6HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR6HDX2 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR6HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module OR6HDX4 (A, B, C, D, E, F, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : OR6HDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 6-Input OR
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A, B, C, D, E, F;
   output    Q;

// logic section:

// Function Q: (A+B+C+D+E+F)
	or	i0 (Q, A, B, C, D, E, F);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
      (B +=> Q) = (0.02, 0.02);
      (C +=> Q) = (0.02, 0.02);
      (D +=> Q) = (0.02, 0.02);
      (E +=> Q) = (0.02, 0.02);
      (F +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFHDX0 (CN, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFHDX1 (CN, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFHDX2 (CN, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFHDX4 (CN, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, delay_SE);
	buf	i7 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	not	i6 (c_SH_D, SE);
	buf	i7 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFQHDX0 (CN, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFQHDX1 (CN, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFQHDX2 (CN, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFQHDX4 (CN, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRHDX0 (CN, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRHDX1 (CN, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRHDX2 (CN, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRHDX4 (CN, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, 1'b1);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, 1'b1);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRQHDX0 (CN, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRQHDX1 (CN, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRQHDX2 (CN, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRQHDX4 (CN, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, 1'b1, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSHDX0 (CN, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSHDX1 (CN, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSHDX2 (CN, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSHDX4 (CN, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_3, IQN, 
		c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, delay_SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, delay_RN, delay_SN);
	not	i8 (SE_not, delay_SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, n_3, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (n_3, IQ);
	and	i4 (IQN, n_3, SN);
	buf	i5 (Q, IQ);
	buf	i6 (QN, IQN);
	checkrs	i7 (c_SH_dat_i, RN, SN);
	not	i8 (SE_not, SE);
	and	i9 (c_SH_D, c_SH_dat_i, SE_not);
	and	i10 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSQHDX0 (CN, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSQHDX1 (CN, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSQHDX2 (CN, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFRSQHDX4 (CN, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, delay_RN, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, delay_RN, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_CN);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, RN, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, RN, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSHDX0 (CN, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSHDX1 (CN, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSHDX2 (CN, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSHDX4 (CN, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, 1'b1, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge CN => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSQHDX0 (CN, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSQHDX1 (CN, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSQHDX2 (CN, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFFSQHDX4 (CN, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFFSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : negedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     CN, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, delay_CN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	not	i0 (clock_i, delay_CN);
	u_mx2	i1 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, delay_SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_D);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SD);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_CN, delay_SE);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_CN);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, clock_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	not	i0 (clock_i, CN);
	u_mx2	i1 (data_i, D, SD, SE);
	u1_fd5	i2 (IQ, data_i, clock_i, 1'b1, SN, NOTIFY_REG);
	not	i3 (IQN, IQ);
	buf	i4 (Q, IQ);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (negedge CN => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(negedge CN &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(negedge CN, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, negedge CN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge CN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR2HDX1 (C, D0, D1, Q0, Q1, QN0, QN1, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, delay_SE);
	buf	i11 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, SE);
	buf	i11 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR2HDX2 (C, D0, D1, Q0, Q1, QN0, QN1, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, delay_SE);
	buf	i11 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	not	i10 (c_SH_D, SE);
	buf	i11 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, delay_SE);
	buf	i21 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, SE);
	buf	i21 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, delay_SE);
	buf	i21 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	not	i20 (c_SH_D, SE);
	buf	i21 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, delay_SE);
	buf	i41 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, SE);
	buf	i41 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFR8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFR8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, delay_SE);
	buf	i41 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	not	i40 (c_SH_D, SE);
	buf	i41 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRHDX0 (C, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRHDX1 (C, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRHDX2 (C, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRHDX4 (C, D, Q, QN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, delay_SE);
	buf	i6 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	not	i5 (c_SH_D, SE);
	buf	i6 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ2HDX1 (C, D0, D1, Q0, Q1, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, delay_SE);
	buf	i9 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, SE);
	buf	i9 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ2HDX2 (C, D0, D1, Q0, Q1, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, delay_SE);
	buf	i9 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	not	i8 (c_SH_D, SE);
	buf	i9 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, delay_SE);
	buf	i17 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, SE);
	buf	i17 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, delay_SE);
	buf	i17 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	not	i16 (c_SH_D, SE);
	buf	i17 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, delay_SE);
	buf	i33 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, SE);
	buf	i33 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQ8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQ8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, delay_SD1, IQ1, 
		IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, delay_SD3, IQ3, IQN3, 
		data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, delay_SD5, IQ5, IQN5, data_i_6,
		 delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, delay_SD7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, delay_SE);
	buf	i33 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, 1'b1, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, 1'b1, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, 1'b1, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, 1'b1, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, 1'b1, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, 1'b1, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, 1'b1, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, 1'b1, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	not	i32 (c_SH_D, SE);
	buf	i33 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQHDX0 (C, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQHDX1 (C, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQHDX2 (C, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRQHDX4 (C, D, Q, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, delay_SE);
	buf	i5 (c_SH_SD, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	not	i4 (c_SH_D, SE);
	buf	i5 (c_SH_SD, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR2HDX1 (C, D0, D1, Q0, Q1, QN0, QN1, RN, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, delay_RN, 1'b1);
	not	i11 (SE_not, delay_SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, RN, 1'b1);
	not	i11 (SE_not, SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR2HDX2 (C, D0, D1, Q0, Q1, QN0, QN1, RN, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1, QN0, QN1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, delay_RN, 1'b1);
	not	i11 (SE_not, delay_SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	buf	i8 (QN0, IQN0);
	buf	i9 (QN1, IQN1);
	checkrs	i10 (c_SH_dat_i, RN, 1'b1);
	not	i11 (SE_not, SE);
	and	i12 (c_SH_D, c_SH_dat_i, SE_not);
	and	i13 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, delay_RN, 1'b1);
	not	i21 (SE_not, delay_SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, RN, 1'b1);
	not	i21 (SE_not, SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3, RN, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3, QN0, QN1, QN2, QN3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, delay_RN, 1'b1);
	not	i21 (SE_not, delay_SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	buf	i16 (QN0, IQN0);
	buf	i17 (QN1, IQN1);
	buf	i18 (QN2, IQN2);
	buf	i19 (QN3, IQN3);
	checkrs	i20 (c_SH_dat_i, RN, 1'b1);
	not	i21 (SE_not, SE);
	and	i22 (c_SH_D, c_SH_dat_i, SE_not);
	and	i23 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, delay_RN, 1'b1);
	not	i41 (SE_not, delay_SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, RN, 1'b1);
	not	i41 (SE_not, SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRR8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRR8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, QN0, QN1, QN2, QN3, QN4, QN5, QN6, QN7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, delay_RN, 1'b1);
	not	i41 (SE_not, delay_SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	buf	i32 (QN0, IQN0);
	buf	i33 (QN1, IQN1);
	buf	i34 (QN2, IQN2);
	buf	i35 (QN3, IQN3);
	buf	i36 (QN4, IQN4);
	buf	i37 (QN5, IQN5);
	buf	i38 (QN6, IQN6);
	buf	i39 (QN7, IQN7);
	checkrs	i40 (c_SH_dat_i, RN, 1'b1);
	not	i41 (SE_not, SE);
	and	i42 (c_SH_D, c_SH_dat_i, SE_not);
	and	i43 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (posedge C => (QN0 -: QN0)) = (0.02, 0.02);
      (posedge C => (QN1 -: QN1)) = (0.02, 0.02);
      (posedge C => (QN2 -: QN2)) = (0.02, 0.02);
      (posedge C => (QN3 -: QN3)) = (0.02, 0.02);
      (posedge C => (QN4 -: QN4)) = (0.02, 0.02);
      (posedge C => (QN5 -: QN5)) = (0.02, 0.02);
      (posedge C => (QN6 -: QN6)) = (0.02, 0.02);
      (posedge C => (QN7 -: QN7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);
      (negedge RN => (QN0 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN1 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN2 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN3 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN4 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN5 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN6 -: RN)) = (0.02, 0.02);
      (negedge RN => (QN7 -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRHDX0 (C, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRHDX1 (C, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRHDX2 (C, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRHDX4 (C, D, Q, QN, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, delay_RN, 1'b1);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, RN, 1'b1);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ2HDX1 (C, D0, D1, Q0, Q1, RN, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ2HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, delay_RN, 1'b1);
	not	i9 (SE_not, delay_SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, RN, 1'b1);
	not	i9 (SE_not, SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ2HDX2 (C, D0, D1, Q0, Q1, RN, SD0, SD1, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ2HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 2-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, RN, SD0, SD1, SE;
   output    Q0, Q1;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, delay_RN, 1'b1);
	not	i9 (SE_not, delay_SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	buf	i6 (Q0, IQ0);
	buf	i7 (Q1, IQ1);
	checkrs	i8 (c_SH_dat_i, RN, 1'b1);
	not	i9 (SE_not, SE);
	and	i10 (c_SH_D, c_SH_dat_i, SE_not);
	and	i11 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ4HDX1 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ4HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, delay_RN, 1'b1);
	not	i17 (SE_not, delay_SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, RN, 1'b1);
	not	i17 (SE_not, SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ4HDX2 (C, D0, D1, D2, D3, Q0, Q1, Q2, Q3, RN, SD0, SD1, SD2, SD3, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ4HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 4-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, RN, SD0, SD1, SD2, SD3, SE;
   output    Q0, Q1, Q2, Q3;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, delay_RN, 1'b1);
	not	i17 (SE_not, delay_SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, c_SH_dat_i, 
		SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	buf	i12 (Q0, IQ0);
	buf	i13 (Q1, IQ1);
	buf	i14 (Q2, IQ2);
	buf	i15 (Q3, IQ3);
	checkrs	i16 (c_SH_dat_i, RN, 1'b1);
	not	i17 (SE_not, SE);
	and	i18 (c_SH_D, c_SH_dat_i, SE_not);
	and	i19 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ8HDX1 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ8HDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, delay_RN, 1'b1);
	not	i33 (SE_not, delay_SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, RN, 1'b1);
	not	i33 (SE_not, SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQ8HDX2 
		(C, D0, D1, D2, D3, D4, D5, D6, D7, Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQ8HDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : 8-Bit posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D0, D1, D2, D3, D4, D5, D6, D7, RN, SD0, SD1, SD2, SD3, SD4, SD5, SD6, SD7, SE;
   output    Q0, Q1, Q2, Q3, Q4, Q5, Q6, Q7;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, delay_C, delay_RN, delay_SE, delay_D0, delay_SD0, IQ0, IQN0, data_i_1, delay_D1, 
		delay_SD1, IQ1, IQN1, data_i_2, delay_D2, delay_SD2, IQ2, IQN2, data_i_3, delay_D3, 
		delay_SD3, IQ3, IQN3, data_i_4, delay_D4, delay_SD4, IQ4, IQN4, data_i_5, delay_D5, 
		delay_SD5, IQ5, IQN5, data_i_6, delay_D6, delay_SD6, IQ6, IQN6, data_i_7, delay_D7, 
		delay_SD7, IQ7, IQN7, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, delay_D0, delay_SD0, delay_SE);
	u1_fd5	i1 (IQ0, data_i_0, delay_C, delay_RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, delay_D1, delay_SD1, delay_SE);
	u1_fd5	i4 (IQ1, data_i_1, delay_C, delay_RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, delay_D2, delay_SD2, delay_SE);
	u1_fd5	i7 (IQ2, data_i_2, delay_C, delay_RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, delay_D3, delay_SD3, delay_SE);
	u1_fd5	i10 (IQ3, data_i_3, delay_C, delay_RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, delay_D4, delay_SD4, delay_SE);
	u1_fd5	i13 (IQ4, data_i_4, delay_C, delay_RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, delay_D5, delay_SD5, delay_SE);
	u1_fd5	i16 (IQ5, data_i_5, delay_C, delay_RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, delay_D6, delay_SD6, delay_SE);
	u1_fd5	i19 (IQ6, data_i_6, delay_C, delay_RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, delay_D7, delay_SD7, delay_SE);
	u1_fd5	i22 (IQ7, data_i_7, delay_C, delay_RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, delay_RN, 1'b1);
	not	i33 (SE_not, delay_SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_D0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_D1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_D2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_D3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_D4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_D5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_D6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_D7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SD0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SD1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SD2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SD3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SD4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SD5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SD6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SD7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6,,, delay_RN, delay_C);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7,,, delay_RN, delay_C);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6,,, delay_C, delay_SE);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG0, NOTIFY_REG1, NOTIFY_REG2, NOTIFY_REG3, NOTIFY_REG4, NOTIFY_REG5, NOTIFY_REG6, 
		NOTIFY_REG7;
	wire    data_i_0, IQ0, IQN0, data_i_1, IQ1, IQN1, data_i_2, IQ2, IQN2, data_i_3, IQ3, IQN3, data_i_4, IQ4, 
		IQN4, data_i_5, IQ5, IQN5, data_i_6, IQ6, IQN6, data_i_7, IQ7, IQN7, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i_0, D0, SD0, SE);
	u1_fd5	i1 (IQ0, data_i_0, C, RN, 1'b1, NOTIFY_REG0);
	not	i2 (IQN0, IQ0);
	u_mx2	i3 (data_i_1, D1, SD1, SE);
	u1_fd5	i4 (IQ1, data_i_1, C, RN, 1'b1, NOTIFY_REG1);
	not	i5 (IQN1, IQ1);
	u_mx2	i6 (data_i_2, D2, SD2, SE);
	u1_fd5	i7 (IQ2, data_i_2, C, RN, 1'b1, NOTIFY_REG2);
	not	i8 (IQN2, IQ2);
	u_mx2	i9 (data_i_3, D3, SD3, SE);
	u1_fd5	i10 (IQ3, data_i_3, C, RN, 1'b1, NOTIFY_REG3);
	not	i11 (IQN3, IQ3);
	u_mx2	i12 (data_i_4, D4, SD4, SE);
	u1_fd5	i13 (IQ4, data_i_4, C, RN, 1'b1, NOTIFY_REG4);
	not	i14 (IQN4, IQ4);
	u_mx2	i15 (data_i_5, D5, SD5, SE);
	u1_fd5	i16 (IQ5, data_i_5, C, RN, 1'b1, NOTIFY_REG5);
	not	i17 (IQN5, IQ5);
	u_mx2	i18 (data_i_6, D6, SD6, SE);
	u1_fd5	i19 (IQ6, data_i_6, C, RN, 1'b1, NOTIFY_REG6);
	not	i20 (IQN6, IQ6);
	u_mx2	i21 (data_i_7, D7, SD7, SE);
	u1_fd5	i22 (IQ7, data_i_7, C, RN, 1'b1, NOTIFY_REG7);
	not	i23 (IQN7, IQ7);
	buf	i24 (Q0, IQ0);
	buf	i25 (Q1, IQ1);
	buf	i26 (Q2, IQ2);
	buf	i27 (Q3, IQ3);
	buf	i28 (Q4, IQ4);
	buf	i29 (Q5, IQ5);
	buf	i30 (Q6, IQ6);
	buf	i31 (Q7, IQ7);
	checkrs	i32 (c_SH_dat_i, RN, 1'b1);
	not	i33 (SE_not, SE);
	and	i34 (c_SH_D, c_SH_dat_i, SE_not);
	and	i35 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q0 -: Q0)) = (0.02, 0.02);
      (posedge C => (Q1 -: Q1)) = (0.02, 0.02);
      (posedge C => (Q2 -: Q2)) = (0.02, 0.02);
      (posedge C => (Q3 -: Q3)) = (0.02, 0.02);
      (posedge C => (Q4 -: Q4)) = (0.02, 0.02);
      (posedge C => (Q5 -: Q5)) = (0.02, 0.02);
      (posedge C => (Q6 -: Q6)) = (0.02, 0.02);
      (posedge C => (Q7 -: Q7)) = (0.02, 0.02);
      (negedge RN => (Q0 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q1 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q2 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q3 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q4 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q5 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q6 +: RN)) = (0.02, 0.02);
      (negedge RN => (Q7 +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, negedge D0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_D, posedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, negedge D1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_D, posedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, negedge D2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_D, posedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, negedge D3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_D, posedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, negedge D4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_D, posedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, negedge D5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_D, posedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, negedge D6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_D, posedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_D, negedge D7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, posedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, negedge SD0, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C &&& c_SH_SD, posedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, negedge SD1, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C &&& c_SH_SD, posedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, negedge SD2, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C &&& c_SH_SD, posedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, negedge SD3, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C &&& c_SH_SD, posedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, negedge SD4, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C &&& c_SH_SD, posedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, negedge SD5, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C &&& c_SH_SD, posedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, negedge SD6, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C &&& c_SH_SD, posedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C &&& c_SH_SD, negedge SD7, 0.02, 0.02, NOTIFY_REG7);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG0);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG1);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG2);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG3);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG4);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG5);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG6);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG0);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG1);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG2);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG3);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG4);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG5);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG6);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG7);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG7);
	$width(posedge C, 0.02, 0, NOTIFY_REG0);
	$width(negedge C, 0.02, 0, NOTIFY_REG0);
	$width(posedge C, 0.02, 0, NOTIFY_REG1);
	$width(negedge C, 0.02, 0, NOTIFY_REG1);
	$width(posedge C, 0.02, 0, NOTIFY_REG2);
	$width(negedge C, 0.02, 0, NOTIFY_REG2);
	$width(posedge C, 0.02, 0, NOTIFY_REG3);
	$width(negedge C, 0.02, 0, NOTIFY_REG3);
	$width(posedge C, 0.02, 0, NOTIFY_REG4);
	$width(negedge C, 0.02, 0, NOTIFY_REG4);
	$width(posedge C, 0.02, 0, NOTIFY_REG5);
	$width(negedge C, 0.02, 0, NOTIFY_REG5);
	$width(posedge C, 0.02, 0, NOTIFY_REG6);
	$width(negedge C, 0.02, 0, NOTIFY_REG6);
	$width(posedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge C, 0.02, 0, NOTIFY_REG7);
	$width(negedge RN, 0.02, 0, NOTIFY_REG0);
	$width(negedge RN, 0.02, 0, NOTIFY_REG1);
	$width(negedge RN, 0.02, 0, NOTIFY_REG2);
	$width(negedge RN, 0.02, 0, NOTIFY_REG3);
	$width(negedge RN, 0.02, 0, NOTIFY_REG4);
	$width(negedge RN, 0.02, 0, NOTIFY_REG5);
	$width(negedge RN, 0.02, 0, NOTIFY_REG6);
	$width(negedge RN, 0.02, 0, NOTIFY_REG7);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQHDX0 (C, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQHDX1 (C, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQHDX2 (C, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRQHDX4 (C, D, Q, RN, SD, SE);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, 1'b1);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, 1'b1, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, 1'b1);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge RN => (Q +: RN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSHDX0 (C, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSHDX1 (C, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSHDX2 (C, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSHDX4 (C, D, Q, QN, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, n_2, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, delay_SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, delay_RN, delay_SN);
	not	i7 (SE_not, delay_SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, n_2, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (n_2, IQ);
	and	i3 (IQN, n_2, SN);
	buf	i4 (Q, IQ);
	buf	i5 (QN, IQN);
	checkrs	i6 (c_SH_dat_i, RN, SN);
	not	i7 (SE_not, SE);
	and	i8 (c_SH_D, c_SH_dat_i, SE_not);
	and	i9 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge RN => (QN -: RN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (SN +=> QN) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSQHDX0 (C, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSQHDX1 (C, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSQHDX2 (C, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRRSQHDX4 (C, D, Q, RN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Reset, Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, RN, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_RN, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, 
		c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, delay_RN, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, delay_RN, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_C);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG,,, delay_RN, delay_SN);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, RN, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, RN, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (RN +=> Q) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge RN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge RN, posedge SN, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge RN, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSHDX0 (C, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSHDX1 (C, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSHDX2 (C, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSHDX4 (C, D, Q, QN, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q, QN;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, delay_SN);
	not	i6 (SE_not, delay_SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	buf	i4 (QN, IQN);
	checkrs	i5 (c_SH_dat_i, 1'b1, SN);
	not	i6 (SE_not, SE);
	and	i7 (c_SH_D, c_SH_dat_i, SE_not);
	and	i8 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (posedge C => (QN -: QN)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);
      (negedge SN => (QN +: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSQHDX0 (C, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSQHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSQHDX1 (C, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSQHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSQHDX2 (C, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSQHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SDFRSQHDX4 (C, D, Q, SD, SE, SN);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SDFRSQHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : posedge single Q D-Flip-Flop with Set and Scan
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     C, D, SD, SE, SN;
   output    Q;

`ifdef NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, delay_C, delay_SN, delay_SE, delay_D, delay_SD, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, 
		c_SH_SD;

	u_mx2	i0 (data_i, delay_D, delay_SD, delay_SE);
	u1_fd5	i1 (IQ, data_i, delay_C, 1'b1, delay_SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, delay_SN);
	not	i5 (SE_not, delay_SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, delay_SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_D);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SD);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG,,, delay_C, delay_SE);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG,,, delay_SN, delay_C);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`else   // NEG_TCHK

// logic section:

	reg     NOTIFY_REG;
	wire    data_i, IQ, IQN, c_SH_dat_i, SE_not, c_SH_D, c_SH_SD;

	u_mx2	i0 (data_i, D, SD, SE);
	u1_fd5	i1 (IQ, data_i, C, 1'b1, SN, NOTIFY_REG);
	not	i2 (IQN, IQ);
	buf	i3 (Q, IQ);
	checkrs	i4 (c_SH_dat_i, 1'b1, SN);
	not	i5 (SE_not, SE);
	and	i6 (c_SH_D, c_SH_dat_i, SE_not);
	and	i7 (c_SH_SD, c_SH_dat_i, SE);

// timing section:
   specify
      (posedge C => (Q -: Q)) = (0.02, 0.02);
      (negedge SN => (Q -: SN)) = (0.02, 0.02);

	$setuphold(posedge C &&& c_SH_D, posedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_D, negedge D, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, posedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C &&& c_SH_SD, negedge SD, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, posedge SE, 0.02, 0.02, NOTIFY_REG);
	$setuphold(posedge C, negedge SE, 0.02, 0.02, NOTIFY_REG);
	$recrem(posedge SN, posedge C, 0.02, 0.02, NOTIFY_REG);
	$width(posedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge C, 0.02, 0, NOTIFY_REG);
	$width(negedge SN, 0.02, 0, NOTIFY_REG);
   endspecify

`endif   // NEG_TCHK
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module SIGNALHOLDDHD ( SIG );
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : SIGNALHOLDDHD
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : Leakage current compensator
//   last modified by : XLIB_PROC generated
//*****************************************************************

   inout SIG;

   wire  n1;

// logic section  
  `ifdef DISPLAY_HOLD 
  
        buf i1 (n1, SIG);
        buf (pull1, pull0) i2 (SIG, n1);

     initial
     begin
      #0 $display("  > Warning: compiler directive DISPLAY_HOLD is set in cell");
         $display("  > %m");
         $display("  > SIGNALHOLD cell model is switched to provide logic levels");
         $display("  >  - danger of reading not really driven values ");    
         $display("  >  - undriven bus states are not detectable now ");    
         $display("  >");    
     end

  `else
// - no logic behaviour modelled for the electrical function of 
//   signalhold cell 
// - signalhold cell compensates leakage current only in case of
//   undriven node/bus and system stop
// - signalhold cell holds the bus bit on "0" or "1", but does not 
//   drive it, this is not in every case the same as the last valid 
//   logic value considering the desired application meaning
// - undriven bus bit should not be used as sequential element
// - reading from undriven bus_bit ("Z") has to provide ("X") in the
//   related block to detect such cases in simulation
//
// Use the compiler directive command
//   `define  DISPLAY_HOLD yes
// to enable the logic pullup/down behaviour of the Leakage current 
// compensator cell SIGNALHOLD*
//
     buf i3 (n1, SIG);
     bufif1 i4 (SIG, n1, 1'b0); /* always inactive */
  `endif
 
// no timing modelled for signalhold cell
// no backannotation possible for signalhold cell 
    
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module STEHDX0 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : STEHDX0
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module STEHDX1 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : STEHDX1
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module STEHDX2 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : STEHDX2
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
`timescale 1ns/10ps

`celldefine

module STEHDX4 (A, Q);
//*****************************************************************
//   technology       : 180 nm bulk CMOS
//   module name      : STEHDX4
//   version          : 5.0.0, Fri Jan 20 09:34:14 2023
//   cell_description : ESD/EMC optimized buffer with CMOS Schmitt Trigger input
//   last modified by : XLIB_PROC generated
//****************************************************************************

   input     A;
   output    Q;

// logic section:

// Function Q: A
	buf	i0 (Q, A);

// timing section:
   specify
      (A +=> Q) = (0.02, 0.02);
   endspecify
endmodule

`endcelldefine
